# 模块

如果你退出 Python 解释器并重新进入，你做的任何定义（变量和方法）都会丢失。
因此，如果你想要编写一些更大的程序，最好使用文本编辑器先编写好，然后运行这个文件。 这就是所谓的创建 脚本。随着你的程序变得越来越长，你可能想要将它分成几个文件，这样更易于维护。
你还可能想在几个程序中**使用你已经编写好的函数**，而不用把函数定义拷贝到每个程序中。


为了支持这个功能，Python 有种方法可以把你定义的内容放到一个文件中，然后在脚本或者交互方式中使用。
这样的文件称为模块；模块中的定义可以导入到其他模块或主模块.

模块是包含 Python 定义和声明的文件。
文件名就是模块名以 扩展名.py 结尾.在模块内部,模块名 (一个字符串) 可以通过一个全局变量 __name__取得.

## 1. 深入
模块可以包含可执行语句以及已定义的函数。这些语句通常用于初始化模块。只有在导入语句中第一次遇到模块名称时，才会执行。

模块中可以导入其它模块。
一般来说，习惯性地将所有 import 语句放在模块 （或脚本，就此而言） 的开头，但这不是必须的。
被导入的模块的名字放在导入模块的全局符号表中。

另外有一种import 语句的变种，可以从一个模块直接将名称导入到导入模块符号表中。例如：
``` python
>>>
>>> from fibo import fib, fib2
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
```
**这不会把模块名导入到本地的符号表中**（所以在本例中，fibo没有定义）。

还有种方式可以导入模块中定义的所有名字：
``` python
>>>
>>> from fibo import *
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
```
这种方式导入除下划线 (_) 开头的所有名称。
大多数情况下Python程序员**不要使用这个便利的方法**，因为它会引入一系列未知的名称到解释器中，这很可能覆盖你已经定义的一些东西。

注意通常情况下从其他module或package中导入*是不被赞同的，因为这会降低代码的可读性。

### 1.1 模块搜索路径
当一个叫spam 的模块被导入，解释器会先在**内置模块**中搜索该模块。

如果没有找到，它会接着到**sys.path**变量给出的目录中查找名为spam.py的文件。
初始化后，Python程序可以修改sys.path。脚本所在的目录被放置在搜索路径的最开始，也就是在标准库的路径之前。这意味着将会加载当前目录中的脚本，库目录中具有相同名称的模块不会被加载。
除非你是有意想替换标准库，否则这应该被当成是一个错误。

### 1.2 "编译好的"Python文件

为了加快加载模块的速度，Python在__pycache__目录下缓存每个模块编译好的版本，名字为module.version.pyc，其中version表示编译好的文件的格式；它一般包含Python的版本号。例如，在CPython 3.3中，spam.py编译好的版本将缓存为 __pycache__/spam.cpython-33.pyc。这种命名约定允许由不同发布和不同版本的Python编译的模块同时存在。

Python会检查源文件和编译好的版本的修改日期，来查看它是否过期以及需要重新编译。这是完全自动化的过程。同时，编译后的模块是跨平台的，所以同一个库可以在不同架构的系统之间共享。

你可以在Python命令中使用-O或者-OO开关来减少编译好的模块的大小。-O开关移除assert语句，-OO移除assert语句和__doc__字符串。
从.pyc文件读取的程序不会比从.py文件读取的程序运行得更快，.pyc文件唯一快的地方在于它们加载的速度。
compileall模块可以为一个目录下的所有模块创建.pyc文件。

内置函数 dir() 用来找出模块中定义了哪些名字。
## 2. 包

包是一种构建 Python 模块的命名空间的方式，采用“点分模块名称”。例如，模块名称A.B指定了包A 中名为B 的子模块。

就像模块的使用让不同模块的作者不用担心相互间的全局变量名称一样，
点分模块的使用让包含多个模块的包（例如 Numpy 和 Python Imaging Library）的作者也**不用担心相互之间的模块重名**。

```
sound/                          Top-level package
      __init__.py               Initialize the sound package
      formats/                  Subpackage for file format conversions
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Subpackage for sound effects
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Subpackage for filters
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
```
当导入包，Python 通过 sys.path 寻找包子目录的目录搜索。

**__init__.py**文件是必需的，这样才能使Python将目录当作包；
这样做的目的是为了**防止将具有共同名字的目录，不小心暴露到模块搜索路径之上**，如string。
最简单的情况，__init__.py 可以只是一个空的文件，但它也可以为包执行初始化代码或设置 __all__ 变量，稍后介绍。

使用类似 import item.subitem.subsubitem 这样的语法时，除了最后一项其它每项必须是一个包；最后一项可以是一个模块或一个包，但不能是在前一个项目中定义的类、函数或变量。

推荐：
``` python
import sound
from sound import echo
```

### 2.1 从包中导入 *
当用户输入 from sound.effects import *时会发生什么?理想情况下，他应该是希望到文件系统中寻找包里面有哪些子模块，并把它们全部导入进来。这可能需要很长时间，而且导入子模块可能会产生想不到的副作用，这些作用本应该只有当子模块是显式导入时才会发生

唯一的解决方案是包作者提供包的显式索引。import语句使用以下约定：如果包中的 __init__.py 代码定义了一个名为__all__的列表，那么在遇到 from package import *语句的时候，应该把这个列表中的所有模块名字导入。当包有新版本包发布时，就需要包的作者更新这个列表了。包作者也可能决定不支持它，如果他们看不到从包中导入*的用途。
例如，文件sound/effects/__init__.py可以包含下面的代码：
``` python
__all__ = ["echo", "surround", "reverse"]
```
如果 __all__ 没有定义，from sound.effects import * 语句 不 会从 sound.effects 包中导入所有的子模块到当前命名空间；它只保证sound.effects包已经被导入（可能会运行__init__.py 中的任何初始化代码），然后导入包中定义的任何名称。



